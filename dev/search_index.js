var documenterSearchIndex = {"docs":
[{"location":"4-differentiate-enzyme-community/#Differentiating-enzyme-constrained-community-models","page":"Differentiating enzyme constrained community models","title":"Differentiating enzyme constrained community models","text":"Construct a community of two interacting E. coli cells that share oxoglutarate and glutamine.\n\nimport DifferentiableMetabolism as D\nimport FastDifferentiation as F\nconst Ex = F.Node\nimport ConstraintTrees as C\nimport AbstractFBCModels as A\nimport JSONFBCModels as JFBC\nimport COBREXA as X\nimport Tulip as T\nimport Downloads: download\nimport CairoMakie as CM","category":"section"},{"location":"4-differentiate-enzyme-community/#Constructing-and-solving-an-enzyme-constrained-community-model","page":"Differentiating enzyme constrained community models","title":"Constructing and solving an enzyme constrained community model","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\ninclude(\"../../test/data_static.jl\")\n\nLoad model, and convert to CanonicalModel for ease of use\n\nmodel = convert(A.CanonicalModel.Model, X.load_model(\"e_coli_core.json\"))\n\nfor rid in [\"ACt2r\", \"ETOHt2r\", \"PYRt2\", \"SUCCt3\"]\n    model.reactions[rid].gene_association_dnf = [[\"s0001\"]]\nend\n\nModify the model a little bit\n\nmodel.reactions[\"EX_glc__D_e\"].lower_bound = -1000.0 # capacity bound suffices\nmodel.reactions[\"PFL\"].upper_bound = 0.0 # aerobic simulation\n\nAdd a transporter for glutamine\n\nmodel.reactions[\"GLNt\"] = A.CanonicalModel.Reaction(;\n    name = \"Glutamine transporter\",\n    lower_bound = -1000.0,\n    upper_bound = 1000.0,\n    stoichiometry = Dict(\n        \"gln__L_e\" => -1.0,\n        \"gln__L_c\" => 1.0,\n        \"h_e\" => -1.0,\n        \"h_c\" => 1.0,\n    ),\n)\n\nreaction_isozymes = Dict{String,Dict{String,X.Isozyme}}()\n\nPopulate reaction_isozymes with parameters\n\nfor rid in A.reactions(model)\n    grrs = A.reaction_gene_association_dnf(model, rid)\n    isnothing(grrs) && continue # skip if no grr available\n    haskey(ecoli_core_reaction_kcats, rid) || continue # skip if no kcat data available\n\n    for (i, grr) in enumerate(grrs)\n\n        kcat = ecoli_core_reaction_kcats[rid] * 3.6 # change unit to k/h\n\n        d = get!(reaction_isozymes, rid, Dict{String,X.Isozyme}())\n        d[\"isozyme_$i\"] = X.Isozyme(\n            gene_product_stoichiometry = Dict(grr .=> fill(1.0, size(grr))),\n            kcat_forward = kcat,\n            kcat_reverse = kcat,\n        )\n    end\nend\n\nMake the wildtype model wt, where we add gene product molar mass and capacity constraint info\n\ngene_product_molar_masses = Dict(k => v for (k, v) in ecoli_core_gene_product_masses)\n\nwt = X.enzyme_constrained_flux_balance_constraints( # reference model, will be used to get some bound info from\n    model;\n    reaction_isozymes,\n    gene_product_molar_masses,\n    capacity = Dict(:total => (Symbol.(A.genes(model)), C.Between(0, 50))),\n    interface = :identifier_prefixes,\n)\n\nMake a glutamine auxotrophic mutant gln_ko\n\ngln_ko = deepcopy(model) # cannot produce glutamine\ndelete!(gln_ko.reactions, \"GLNS\") # KO reaction\n\n\ngln_ko.reactions[\"EX_gln__L_e\"].lower_bound = -1000.0 # open exchange bound to other organism\n\nMake an oxoglutarate auxotrophic mutant akg_ko\n\nakg_ko = deepcopy(model) # cannot produce oxoglutarate\ndelete!(akg_ko.reactions, \"ICDHyr\") # KO reaction\n\n\nakg_ko.reactions[\"EX_akg_e\"].lower_bound = -1000.0 # open exchange bound to other organism\n\nAdd isozymes, gene product molar masses, and capacity constraints to the KO mutants\n\nec_gln_ko = X.enzyme_constrained_flux_balance_constraints(\n    gln_ko;\n    reaction_isozymes,\n    gene_product_molar_masses,\n    capacity = Dict(:total => (Symbol.(A.genes(model)), C.Between(0, 50))),\n    interface = :identifier_prefixes,\n)\n\nec_akg_ko = X.enzyme_constrained_flux_balance_constraints(\n    akg_ko;\n    reaction_isozymes,\n    gene_product_molar_masses,\n    capacity = Dict(:total => (Symbol.(A.genes(model)), C.Between(0, 50))),\n    interface = :identifier_prefixes,\n)\n\nBound the exchanges - adopt similar bounds to wt wrt to the environment\n\nboundf(id) = begin\n    ex_id = first(id)\n    wt.interface.exchanges[ex_id].bound\nend\n\nCreate KO pairs to be joined via their exchanges\n\nko_pairs = [\n    :gln => (ec_gln_ko, ec_gln_ko.interface.exchanges, 0.5) # simulate at abundance of 0.5 for each organism\n    :akg => (ec_akg_ko, ec_akg_ko.interface.exchanges, 0.5)\n]\n\nCreate community model, where interface joins the two enzyme constrained KO models\n\nx = X.interface_constraints(ko_pairs...; bound = boundf)\n\nSet all growth rates equal\n\nx *= :equalgrowth^C.Constraint(x.gln.objective.value - x.akg.objective.value, C.EqualTo(0))\n\nSet objective as any of the biomass functions (they are constrained equal)\n\nx *= :objective^C.Constraint(x.gln.objective.value, nothing)\n\nsol = X.optimized_values( # test that community can grow\n    x;\n    optimizer = T.Optimizer,\n    objective = x.objective.value,\n    sense = X.Maximal,\n    settings = [X.set_optimizer_attribute(\"IPM_IterationsLimit\", 10_000)],\n)","category":"section"},{"location":"4-differentiate-enzyme-community/#Pruning-the-community","page":"Differentiating enzyme constrained community models","title":"Pruning the community","text":"Now prune the base models. Here it is slighty more involved than in the case of a single enzyme constrained model.\n\ninfo: Pruning the model can be tricky\nFor a unique, and therefore differentiable solution, it is important to ensure that no zero fluxes are included in the model.\n\npruned_akg_ko, pruned_isozymes_akg = D.prune_model(\n    akg_ko,\n    sol.akg.fluxes,\n    sol.akg.gene_product_amounts,\n    reaction_isozymes,\n    sol.akg.isozyme_forward_amounts,\n    sol.akg.isozyme_reverse_amounts,\n    1e-6,\n    1e-6,\n);\n\npruned_gln_ko, pruned_isozymes_gln = D.prune_model(\n    gln_ko,\n    sol.gln.fluxes,\n    sol.gln.gene_product_amounts,\n    reaction_isozymes,\n    sol.gln.isozyme_forward_amounts,\n    sol.gln.isozyme_reverse_amounts,\n    1e-6,\n    1e-6,\n);\nnothing #hide\n\nMake the pruned enzyme constrained KO models\n\nec_gln_ko = X.enzyme_constrained_flux_balance_constraints(\n    pruned_gln_ko;\n    reaction_isozymes = pruned_isozymes_gln,\n    gene_product_molar_masses,\n    capacity = Dict(:total => (Symbol.(A.genes(model)), C.Between(0, 50))),\n    interface = :identifier_prefixes,\n)\n\nec_akg_ko = X.enzyme_constrained_flux_balance_constraints(\n    pruned_akg_ko;\n    reaction_isozymes = pruned_isozymes_akg,\n    gene_product_molar_masses,\n    capacity = Dict(:total => (Symbol.(A.genes(model)), C.Between(0, 50))),\n    interface = :identifier_prefixes,\n)\n\nBound the exchanges - adopt similar bounds to wt wrt to the environment\n\nenv = deepcopy(ec_gln_ko.interface.exchanges)\n\ninfo: Delete the KO exchanges\nExchanges of akg and gln to the environment need to be deleted! Otherwise, a zero flux will be introduced\n\ndelete!(env, :EX_akg_e)\ndelete!(env, :EX_gln__L_e)\nenv\n\nboundf(id) = begin\n    ex_id = first(id)\n    env[ex_id].bound\nend\n\nIgnore the deleted bound, it is still in the interface of each organism and will generate an error if not ignored\n\nignoref(id, p) = begin\n    (id == :gln || id == :akg) && (:EX_gln__L_e in p || :EX_akg_e in p)\nend","category":"section"},{"location":"4-differentiate-enzyme-community/#Investigating-sensitivity-of-variables-to-the-organism-abundances","page":"Differentiating enzyme constrained community models","title":"Investigating sensitivity of variables to the organism abundances","text":"We want to see how sensitive the variables of both KO models are to the abundances of each organism in the community.\n\nF.@variables abundance_gln abundance_akg\n\nAdd parameters into a community construction\n\nko_pairs = [\n    :gln => (ec_gln_ko, ec_gln_ko.interface.exchanges, abundance_gln)\n    :akg => (ec_akg_ko, ec_akg_ko.interface.exchanges, abundance_akg)\n]\n\nCreate community model (interface` joins them)\n\nx = X.interface_constraints(ko_pairs...; bound = boundf, ignore = ignoref)\n\nJoin partner exchanges - need to do this to avoid making a 0 env variable\n\nx.interface_balance *=\n    :akg^C.Constraint(\n        abundance_akg * x.akg.interface.exchanges.EX_akg_e.value -\n        abundance_gln * x.gln.interface.exchanges.EX_akg_e.value,\n        C.EqualTo(0),\n    )\nx.interface_balance *=\n    :gln^C.Constraint(\n        abundance_akg * x.akg.interface.exchanges.EX_gln__L_e.value -\n        abundance_gln * x.gln.interface.exchanges.EX_gln__L_e.value,\n        C.EqualTo(0),\n    )\n\nSet all growth rates equal\n\nx *= :equalgrowth^C.Constraint(x.gln.objective.value - x.akg.objective.value, C.EqualTo(0))\n\nSet objective as any of the biomass functions (they are constrained equal)\n\nx *= :objective^C.Constraint(x.gln.objective.value, nothing)\n\nparam_vals = Dict(:abundance_gln => 0.5, :abundance_akg => 0.5)\n\npruned_sol = D.optimized_values(\n    x,\n    param_vals;\n    optimizer = T.Optimizer,\n    objective = x.objective.value,\n    sense = X.Maximal,\n    settings = [X.set_optimizer_attribute(\"IPM_IterationsLimit\", 10_000)],\n)\npruned_sol.tree\n\nWant to differenciate with respect to the parameters abundance_akg and abundance_gln, the respective abundances of the two KO mutants\n\ndparams = [:abundance_akg, :abundance_gln]\n\nPrepare and calculate derivatives\n\npm_kkt, vids = D.differentiate_prepare_kkt(x, x.objective.value, dparams)\n\nsens = D.differentiate_solution(\n    pm_kkt,\n    pruned_sol.primal_values,\n    pruned_sol.equality_dual_values,\n    pruned_sol.inequality_dual_values,\n    param_vals,\n    scale = true, # unitless sensitivities\n)\n\nOnly look at how the abundances impact the environmental exchanges\n\nenv_exs = string.(last.(vids)[(end-7):end])\n\nNow we plot the environmental exchanges\n\nfig, ax, hm = CM.heatmap(\n    sens[(end-7):end, :];\n    axis = (\n        xticks = (1:8, env_exs),\n        xticklabelrotation = -pi / 2,\n        yticks = (1:2, string.(dparams)),\n    ),\n)\nCM.Colorbar(fig[1, 2], hm)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"3-parameter-estimation/#Parameter-estimation-using-proteomics-and-flux-data","page":"Parameter estimation using proteomics and flux data","title":"Parameter estimation using proteomics and flux data","text":"import DifferentiableMetabolism as D\nimport FastDifferentiation as F\nconst Ex = F.Node\nimport ConstraintTrees as C\nimport AbstractFBCModels as A\nimport COBREXA as X\nimport Tulip as T\nimport Clarabel as Q\nimport CairoMakie as CM","category":"section"},{"location":"3-parameter-estimation/#Setting-up-the-test-model","page":"Parameter estimation using proteomics and flux data","title":"Setting up the test model","text":"include(\"../../test/simple_model.jl\");\nnothing #hide\n\n(Image: simple_model)\n\nPrune the model\n\ndelete!(model.reactions, \"r5\")\ndelete!(model.genes, \"g4\")\ndelete!(model.genes, \"g5\")\ndelete!(model.genes, \"g3\")\nmodel.reactions[\"r4\"].gene_association_dnf = [[\"g2\"]]\nmodel.reactions[\"r1\"].lower_bound = -1000.0\nmodel.reactions[\"r2\"].lower_bound = -1000.0\n\nThe model now looks like this\n\n(Image: simple_model)\n\nUse the two reactions r3 and r4 as variables\n\nF.@variables r3 r4\n\nMake parameterised reaction isozymes for these two reactions\n\nreaction_isozymes = Dict(\n    \"r3\" => Dict(\n        \"isozyme1\" => X.IsozymeT{Ex}(\n            gene_product_stoichiometry = Dict(\"g1\" => 1.0),\n            kcat_forward = r3,\n            kcat_reverse = nothing,\n        ),\n    ),\n    \"r4\" => Dict(\n        \"isozyme1\" => X.IsozymeT{Ex}(\n            gene_product_stoichiometry = Dict(\"g2\" => 1.0),\n            kcat_forward = r4,\n            kcat_reverse = nothing,\n        ),\n    ),\n)\n\nInclude gene product masses and a capacity limitation\n\ngene_product_molar_masses = Dict(\"g1\" => 20.0, \"g2\" => 10.0)\n\nF.@variables capacitylimitation\n\ntrue_parameter_values = Dict(:capacitylimitation => 50.0, :r3 => 2.0, :r4 => 3.0)\n\nSolve the parameterised enzymed constrained model\n\nkm = X.enzyme_constrained_flux_balance_constraints(\n    model;\n    reaction_isozymes,\n    gene_product_molar_masses,\n    capacity = Dict(\n        :total => (Symbol.(A.genes(model)), C.BetweenT(Ex(0), capacitylimitation)),\n    ),\n)\n\nsol = D.optimized_values(\n    km,\n    true_parameter_values;\n    objective = km.objective.value,\n    optimizer = T.Optimizer,\n)\n\nsol.tree.fluxes","category":"section"},{"location":"3-parameter-estimation/#Performing-the-parameter-estimation","page":"Parameter estimation using proteomics and flux data","title":"Performing the parameter estimation","text":"First, we need to create a loss function\n\nmeasured = [\n    sol.tree.fluxes.r1,\n    sol.tree.fluxes.r3,\n    sol.tree.isozyme_forward_amounts.r3.isozyme1,\n    sol.tree.isozyme_forward_amounts.r4.isozyme1,\n]\n\nkm *=\n    :loss^C.Constraint(;\n        value = 0.5 * (\n            C.squared(km.fluxes.r1.value - measured[1]) +\n            C.squared(km.fluxes.r3.value - measured[2]) +\n            C.squared(km.isozyme_forward_amounts.r3.isozyme1.value - measured[3]) +\n            C.squared(km.isozyme_forward_amounts.r4.isozyme1.value - measured[4])\n        ),\n        bound = nothing,\n    )\n\nestimated_parameters = Dict(:capacitylimitation => 50.0, :r3 => 5.0, :r4 => 1.0) # initial values\nη = 0.1 # learning rate\n\nlosses = Float64[]\n\nPrepare for differentiating, this is the slow part\n\nkmKKT, vids =\n    D.differentiate_prepare_kkt(km, km.loss.value, [:r3, :r4, :capacitylimitation])\n\nEstimate the parameters\n\nfor k = 1:150\n\n    _sol = D.optimized_values(\n        km,\n        estimated_parameters;\n        objective = km.loss.value,\n        optimizer = Q.Optimizer,\n        sense = X.Minimal,\n        settings = [X.silence],\n    )\n    push!(losses, _sol.tree.loss)\n\n    sens = D.differentiate_solution(\n        kmKKT,\n        _sol.primal_values,\n        _sol.equality_dual_values,\n        _sol.inequality_dual_values,\n        estimated_parameters,\n    ) # derivative of variables wrt parameters\n\n    dL_dx = D.differentiate_objective(\n        kmKKT,\n        _sol.primal_values,\n        _sol.equality_dual_values,\n        _sol.inequality_dual_values,\n        estimated_parameters,\n    ) # derivative of loss function wrt variables\n\n    dL_dkcats = sens' * dL_dx # derivative of loss function wrt parameters\n\n    estimated_parameters[:r3] -= η * dL_dkcats[1]\n    estimated_parameters[:r4] -= η * dL_dkcats[2]\nend\n\nFinally, we plot the loss function over 150 iterations\n\nCM.lines(losses; axis = (xlabel = \"Iterations\", ylabel = \"L2 loss\"))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"1-parametric-models/#Parametric-constraint-based-metabolic-models","page":"Parametric constraint-based metabolic models","title":"Parametric constraint-based metabolic models","text":"import DifferentiableMetabolism as D\nimport FastDifferentiation as F\nconst Ex = F.Node\nimport ConstraintTrees as C\nimport COBREXA as X\nimport Tulip as T\nimport Clarabel as Q","category":"section"},{"location":"1-parametric-models/#Load-and-solve-a-simple-model","page":"Parametric constraint-based metabolic models","title":"Load and solve a simple model","text":"Load a small test model\n\ninclude(\"../../test/simple_model.jl\");\nnothing #hide\n\n(Image: simple_model)\n\nmodel\n\nBuild a basic ConstraintTree model without parameters\n\nm = X.flux_balance_constraints(model)\n\nSolve normally\n\nbase_model = X.optimized_values(m; optimizer = T.Optimizer, objective = m.objective.value)\nbase_model.fluxes","category":"section"},{"location":"1-parametric-models/#Add-parameters-to-the-model","page":"Parametric constraint-based metabolic models","title":"Add parameters to the model","text":"Make bound of r2 and mass balance of m3 parameters\n\nF.@variables r2bound m3bound\n\nm.fluxes.r2 = C.Constraint(m.fluxes.r2.value, C.BetweenT(-2 * r2bound, Ex(0)))\n\nm.flux_stoichiometry.m3 =\n    C.Constraint(m.flux_stoichiometry.m3.value, C.EqualToT(m3bound) / 2)\n\ntip: Use the generalized bounds from ConstraintTrees\nNote, ConstraintTrees.jl exports Between and EqualTo which are specialized to Float64. To use parameters as shown here, you must use the more general types BetweenT and EqualToT. Appropriate overloads have been added to simplify type promotion when adding floaty bounds to symbolic bounds.","category":"section"},{"location":"1-parametric-models/#Add-parametric-constraints","page":"Parametric constraint-based metabolic models","title":"Add parametric constraints","text":"p = F.make_variables(:p, 4)\n\nm *=\n    :linparam^C.Constraint(\n        value = p[1] * m.fluxes.r1.value + p[2] * m.fluxes.r2.value,\n        bound = C.BetweenT(-p[3], Ex(0)),\n    )\n\ntip: Use the generalized value types from ConstraintTrees\nNote, ConstraintTrees.jl exports LinearValue and QuadraticValue which are specialized to Float64. To use parameters as shown here, you must use the more general types LinearValueT and QuadraticValueT. Appropriate overloads have been added to simplify type construction and promotion (as used above). But note that m.linparam.value is a ConstraintTrees.LinearValueT{FastDifferentiation.Node}.\n\nSubstitute parameters into model to yield a \"normal\" constraint tree model\n\nparameter_substitutions = Dict(\n    :r2bound => 4.0,\n    :m3bound => 0.1, # lose some mass here\n    :p1 => 1.0,\n    :p2 => 1.0,\n    :p3 => 4.0,\n)\n\nm_substituted = D.substitute(m, k -> parameter_substitutions[k])\n\nThis can be solved like any constraint tree\n\nm_normal = X.optimized_values(\n    m_substituted,\n    objective = m.objective.value,\n    optimizer = T.Optimizer,\n)\n\nAlternatively, a convenience function can take care of the substitutions for you\n\nm_noparams = D.optimized_values(\n    m,\n    parameter_substitutions;\n    objective = m.objective.value,\n    optimizer = T.Optimizer,\n)","category":"section"},{"location":"1-parametric-models/#Change-the-parameters-and-re-solve","page":"Parametric constraint-based metabolic models","title":"Change the parameters and re-solve","text":"Substitute parameters into model\n\nparameter_substitutions[:m3bound] = 0.0\n\nm_noparams2 = D.optimized_values(\n    m,\n    parameter_substitutions;\n    objective = m.objective.value,\n    optimizer = T.Optimizer,\n)\n\nm_noparams2.tree.fluxes","category":"section"},{"location":"1-parametric-models/#Quadratic-parameters-also-work","page":"Parametric constraint-based metabolic models","title":"Quadratic parameters also work","text":"q = F.make_variables(:q, 6)\n\nm.objective = C.Constraint(\n    value = sum(\n        rxn.value * rxn.value * qi for (qi, rxn) in zip(collect(q), values(m.fluxes))\n    ),\n    bound = nothing,\n)\n\nm *= :objective_bound^C.Constraint(value = m.fluxes.r6.value, bound = 2.0)\n\nparameter_substitutions =\n    merge(parameter_substitutions, Dict(v.node_value => 1.0 for v in q))\n\nm_noparams3 = D.optimized_values(\n    m,\n    parameter_substitutions;\n    objective = m.objective.value,\n    optimizer = Q.Optimizer,\n    sense = X.Minimal,\n)\n\nm_noparams3.tree.fluxes\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"2-differentiate-enzyme-model/#Differentiating-enzyme-constrained-metabolic-models","page":"Differentiating enzyme constrained metabolic models","title":"Differentiating enzyme constrained metabolic models","text":"import DifferentiableMetabolism as D\nimport FastDifferentiation as F\nconst Ex = F.Node\nimport ConstraintTrees as C\nimport AbstractFBCModels as A\nimport JSONFBCModels as JFBC\nimport COBREXA as X\nimport Tulip as T\nimport Clarabel as Q\nimport Downloads: download\nimport CairoMakie as CM","category":"section"},{"location":"2-differentiate-enzyme-model/#Constructing-a-parameterised-enzyme-constrained-model","page":"Differentiating enzyme constrained metabolic models","title":"Constructing a parameterised enzyme constrained model","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\ninclude(\"../../test/data_static.jl\")\n\nLoad model, and convert to CanonicalModel for ease of use\n\nmodel = convert(A.CanonicalModel.Model, X.load_model(\"e_coli_core.json\"))\n\nfor rid in [\"ACt2r\", \"ETOHt2r\", \"PYRt2\", \"SUCCt3\"]\n    model.reactions[rid].gene_association_dnf = [[\"s0001\"]]\nend\n\nModify the model a little bit\n\nmodel.reactions[\"EX_glc__D_e\"].lower_bound = -1000.0 # capacity bound suffices\nmodel.reactions[\"PFL\"].upper_bound = 0.0 # aerobic simulation\n\nCreate parameters of all kcats\n\nrid_kcat = Dict(k => Ex(Symbol(k)) for (k, _) in ecoli_core_reaction_kcats)\n\nCreate a lookup table to map parameters to values\n\nparameter_values = Dict{Symbol,Float64}()\n\nCreate a symbolic reaction_isozyme structure to feed into COBREXA. This is where we first introduce the kcats as parameters\n\nreaction_isozymes = Dict{String,Dict{String,X.IsozymeT{Ex}}}() # a mapping from reaction IDs to isozyme IDs to isozyme structs.\n\nPopulate reaction_isozymes with parameters\n\nfor rid in A.reactions(model)\n    grrs = A.reaction_gene_association_dnf(model, rid)\n    isnothing(grrs) && continue # skip if no grr available\n    haskey(ecoli_core_reaction_kcats, rid) || continue # skip if no kcat data available\n\n    for (i, grr) in enumerate(grrs)\n\n        kcat = ecoli_core_reaction_kcats[rid] * 3.6 # change unit to k/h\n        parameter_values[Symbol(rid)] = kcat # to substitute later\n\n        d = get!(reaction_isozymes, rid, Dict{String,X.IsozymeT{Ex}}()) # NB: IsozymeT\n        d[\"isozyme_$i\"] = X.IsozymeT{Ex}(\n            gene_product_stoichiometry = Dict(grr .=> fill(1.0, size(grr))), # assume subunit stoichiometry of 1 for all isozymes\n            kcat_forward = rid_kcat[rid], # assume forward and reverse have the same kcat\n            kcat_reverse = rid_kcat[rid],\n        )\n\n    end\nend\n\ntip: Use the generalized IsozymeT struct from COBREXA\nNote, COBREXA.jl exports Isozyme which is specialized to Float64. To use parameters as shown here, you must use the more general type IsozymeT.\n\nAdd gene product molar mass and capacity constraint info\n\ngene_product_molar_masses = Dict(k => v for (k, v) in ecoli_core_gene_product_masses)\n\nF.@variables capacitylimitation\nparameter_values[:capacitylimitation] = 50.0 # mg enzyme/gDW\n\nCreate and solve a COBREXA enzyme constrained model\n\nkm = X.enzyme_constrained_flux_balance_constraints( # kinetic model\n    model;\n    reaction_isozymes,\n    gene_product_molar_masses,\n    capacity = Dict(\n        :total => (Symbol.(A.genes(model)), C.BetweenT(Ex(0), capacitylimitation)),\n    ),\n)\n\nec_solution = D.optimized_values(\n    km,\n    parameter_values;\n    objective = km.objective.value,\n    optimizer = T.Optimizer,\n    settings = [X.set_optimizer_attribute(\"IPM_IterationsLimit\", 10_000)],\n)\n\nec_solution.tree\n\nNote, this solution contains many inactive reactions\n\nsort(collect(ec_solution.tree.fluxes), by = ComposedFunction(abs, last))\n\nAnd also many inactive gene products.\n\nsort(collect(ec_solution.tree.gene_product_amounts), by = last)","category":"section"},{"location":"2-differentiate-enzyme-model/#Pruning-the-parameterised-model","page":"Differentiating enzyme constrained metabolic models","title":"Pruning the parameterised model","text":"With theory, you can show that the inactive reactions introduce flux variability into the solution, making it non-unique, and consequently non-differentiable. To fix this, one needs to prune the model, to keep only the active reactions and genes. This can be differentiated uniquely. Below we build a pruned kinetic model, by removing all the reactions, metabolites, and genes that are not active.\n\nflux_zero_tol = 1e-6 # these bounds make a real difference!\ngene_zero_tol = 1e-6\n\npruned_model, pruned_reaction_isozymes = D.prune_model(\n    model,\n    ec_solution.tree.fluxes,\n    ec_solution.tree.gene_product_amounts,\n    reaction_isozymes,\n    ec_solution.tree.isozyme_forward_amounts,\n    ec_solution.tree.isozyme_reverse_amounts,\n    flux_zero_tol,\n    gene_zero_tol,\n);\n\npruned_model\n\n\npkm = X.enzyme_constrained_flux_balance_constraints( # pruned kinetic model\n    pruned_model;\n    reaction_isozymes = pruned_reaction_isozymes,\n    gene_product_molar_masses,\n    capacity = Dict(\n        :total =>\n            (Symbol.(A.genes(pruned_model)), C.BetweenT(Ex(0), capacitylimitation)),\n    ),\n)\n\npruned_solution = D.optimized_values(\n    pkm,\n    parameter_values;\n    objective = pkm.objective.value,\n    optimizer = T.Optimizer,\n    settings = [X.set_optimizer_attribute(\"IPM_IterationsLimit\", 10_000)],\n)\n\nNotice, the solution is exactly the same as before, except that all the inactive elements are gone.\n\npruned_solution.tree\n\nThere are no zero fluxes and all fluxes are made positive!\n\nsort(collect(pruned_solution.tree.fluxes), by = ComposedFunction(abs, last))\n\nNo zero genes\n\nsort(abs.(collect(values(pruned_solution.tree.gene_product_amounts))))","category":"section"},{"location":"2-differentiate-enzyme-model/#Differentiating-the-optimal-solution","page":"Differentiating enzyme constrained metabolic models","title":"Differentiating the optimal solution","text":"Now we will differentiate the solution. First select parameters that will be differentiated, here it is the kcats and the capacity bound.\n\nkcats = Symbol.(keys(pruned_reaction_isozymes))\nparameters = [:capacitylimitation; kcats]\n\nNext prepare the model for differentiation\n\npkm_kkt, vids = D.differentiate_prepare_kkt(pkm, pkm.objective.value, parameters)\n\nNow differentiate the solution\n\nsens = D.differentiate_solution(\n    pkm_kkt,\n    pruned_solution.primal_values,\n    pruned_solution.equality_dual_values,\n    pruned_solution.inequality_dual_values,\n    parameter_values,\n    scale = true, # unitless sensitivities\n)\n\nLet's look at oxidative phosphorylation only\n\nsubset_ids = [:CYTBD, :NADH16, :ATPS4r]\n\nflux_idxs = findall(x -> last(x) in subset_ids && first(x) == :fluxes, vids)\nflux_ids = last.(vids[flux_idxs])\n\nparam_idxs = findall(x -> x in subset_ids, parameters)\nparam_ids = parameters[param_idxs]","category":"section"},{"location":"2-differentiate-enzyme-model/#Visualising-flux-sensitivities","page":"Differentiating enzyme constrained metabolic models","title":"Visualising flux sensitivities","text":"The flux sensitivities of these three reactions to the model parameters are visualised in a heatmap\n\nf, a, hm = CM.heatmap(\n    sens[flux_idxs, param_idxs]';\n    axis = (\n        xlabel = \"kcat\",\n        xticks = (1:length(param_ids), string.(param_ids)),\n        xticklabelrotation = -pi / 2,\n        ylabel = \"Flux\",\n        yticks = (1:length(flux_ids), string.(flux_ids)),\n        title = \"Flux sensitivities\",\n    ),\n)\nCM.Colorbar(f[1, 2], hm)\nf","category":"section"},{"location":"2-differentiate-enzyme-model/#Visualising-isozyme-sensitivities","page":"Differentiating enzyme constrained metabolic models","title":"Visualising isozyme sensitivities","text":"Note, the gene products themselves are not variables in the formulation of the kinetic model. It inherits its structure from COBREXA, where the gene products are derived variables. If you want the sensitivities of the gene products themselves, you just need to multiply the isozyme sensitivity with the subunit stoichiometry of the relevant gene products.\n\niso_idxs = findall(x -> x[2] in subset_ids && occursin(\"isozyme\", string(x[1])), vids)\niso_ids = [v[2] for v in vids[iso_idxs]] # ids of isozymes in ox phos\n\nf, a, hm = CM.heatmap(\n    sens[iso_idxs, param_idxs]';\n    axis = (\n        xlabel = \"kcat\",\n        xticks = (1:length(param_ids), string.(param_ids)),\n        xticklabelrotation = -pi / 2,\n        ylabel = \"Isozyme\",\n        yticks = (1:length(iso_ids), string.(iso_ids)),\n        title = \"Isozyme sensitivities\",\n    ),\n)\nCM.Colorbar(f[1, 2], hm)\nf\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Solver-implementation","page":"Reference","title":"Solver implementation","text":"","category":"section"},{"location":"reference/#Overloads","page":"Reference","title":"Overloads","text":"","category":"section"},{"location":"reference/#Pruning-models","page":"Reference","title":"Pruning models","text":"","category":"section"},{"location":"reference/#Differentiation-of-pruned-models","page":"Reference","title":"Differentiation of pruned models","text":"","category":"section"},{"location":"reference/#DifferentiableMetabolism.constraint_matrix_vector-Tuple{Any, Any, Any}","page":"Reference","title":"DifferentiableMetabolism.constraint_matrix_vector","text":"constraint_matrix_vector(\n    eqs,\n    m,\n    parameters\n) -> Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseVector{Float64, Int64}}\n\n\nBuilds a matrix representation of bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.optimization_model-Tuple{ConstraintTrees.ConstraintTree, Dict{Symbol, Float64}}","page":"Reference","title":"DifferentiableMetabolism.optimization_model","text":"optimization_model(\n    m::ConstraintTrees.ConstraintTree,\n    parameters::Dict{Symbol, Float64};\n    objective,\n    optimizer,\n    sense\n)\n\n\nConstruct a JuMP model by substituting parameters into the model, m. Set the objective and the optimizer, as well as the sense similar to COBREXA.optimization_model.\n\nConverts all inequality constraints to the form A * x ≤ b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.optimized_values-Tuple{ConstraintTrees.ConstraintTree, Dict{Symbol, Float64}}","page":"Reference","title":"DifferentiableMetabolism.optimized_values","text":"optimized_values(\n    model::ConstraintTrees.ConstraintTree,\n    parameters::Dict{Symbol, Float64};\n    optimizer,\n    settings,\n    objective,\n    sense\n)\n\n\nSolve a model using optimizer by substituting in parameters. Optional arguments are the same as in COBREXA.\n\nIf the model does not solve successfully return nothing. Otherwise, return a named tuple of the solution tree, and vectors containing the values of the primal variables, the dual variables.\n\nThese duals are ordered according to the constraint output of calling equality_constraints and inequality_constraints respectively.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.equality_constraints-Tuple{ConstraintTrees.ConstraintTree}","page":"Reference","title":"DifferentiableMetabolism.equality_constraints","text":"equality_constraints(\n    m::ConstraintTrees.ConstraintTree\n) -> Vector{Tuple{Union{ConstraintTrees.LinearValueT{FastDifferentiation.Node}, ConstraintTrees.LinearValue}, FastDifferentiation.Node}}\n\n\nReturn all the equality constraints of m as a tuple (constraint, bound) representing constraint == bound for each entry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.get_equality_constraints-Tuple{ConstraintTrees.Constraint, Any}","page":"Reference","title":"DifferentiableMetabolism.get_equality_constraints","text":"get_equality_constraints(\n    c::ConstraintTrees.Constraint,\n    sink\n) -> Any\n\n\nHelper function for equality_constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.get_equality_constraints-Tuple{ConstraintTrees.ConstraintTree, Any}","page":"Reference","title":"DifferentiableMetabolism.get_equality_constraints","text":"get_equality_constraints(\n    m::ConstraintTrees.ConstraintTree,\n    sink\n) -> Any\n\n\nHelper function for equality_constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.get_inequality_constraints-Tuple{ConstraintTrees.Constraint, Any}","page":"Reference","title":"DifferentiableMetabolism.get_inequality_constraints","text":"get_inequality_constraints(\n    c::ConstraintTrees.Constraint,\n    sink\n) -> Any\n\n\nHelper function for inequality_constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.get_inequality_constraints-Tuple{ConstraintTrees.ConstraintTree, Any}","page":"Reference","title":"DifferentiableMetabolism.get_inequality_constraints","text":"get_inequality_constraints(\n    m::ConstraintTrees.ConstraintTree,\n    sink\n) -> Any\n\n\nHelper function for inequality_constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.inequality_constraints-Tuple{ConstraintTrees.ConstraintTree}","page":"Reference","title":"DifferentiableMetabolism.inequality_constraints","text":"inequality_constraints(\n    m::ConstraintTrees.ConstraintTree\n) -> Vector\n\n\nReturn all the inequality constraints of m as a tuple of bounds converted to the form (constraint, upper) representing constraint ≤ upper for each entry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.is_constrained-Tuple{Any}","page":"Reference","title":"DifferentiableMetabolism.is_constrained","text":"is_constrained(x) -> Bool\n\n\nCheck if the argument is constrained (i.e. bound not infinity) or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.substitute-Tuple{FastDifferentiation.Node, Any}","page":"Reference","title":"DifferentiableMetabolism.substitute","text":"substitute(x::FastDifferentiation.Node, lookup) -> Any\n\n\nStraightforward recursive evaluator for Exs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.variable_order-Tuple{Any}","page":"Reference","title":"DifferentiableMetabolism.variable_order","text":"variable_order(m) -> Any\n\n\nReturn the names of variables in m.\n\nNOTE: this function assumes that all variables are bounded explicitly in the model. nothing bounds are ignored.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.prune_model-Tuple{AbstractFBCModels.CanonicalModel.Model, Any, Any, Any, Any, Any, Float64, Float64}","page":"Reference","title":"DifferentiableMetabolism.prune_model","text":"prune_model(\n    model::AbstractFBCModels.CanonicalModel.Model,\n    solution_fluxes,\n    solution_gene_product_amounts,\n    reaction_isozymes,\n    solution_isozyme_forward_amounts,\n    solution_isozyme_reverse_amounts,\n    flux_zero_tol::Float64,\n    gene_zero_tol::Float64\n) -> Tuple{AbstractFBCModels.CanonicalModel.Model, Dict}\n\n\nPrune away reactions, metabolites, and genes from a model using solution. Additionally, adjust reaction_isozymes using prune_reaction_isozymes to account for the changed directions of the fluxes.\n\nFluxes and gene product concentrations smaller than flux_zero_tol, gene_zero_tol are removed. Metabolites that do not take part in the remaining reactions are also removed.\n\nNote, in COBREXA reverse variables are always derived quantities, hence making everything forward orientated ensures that the variables of the whole model are just these.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.prune_reaction_isozymes-Tuple{Any, Any, Any, Any, Float64}","page":"Reference","title":"DifferentiableMetabolism.prune_reaction_isozymes","text":"prune_reaction_isozymes(\n    reaction_isozymes,\n    solution_isozyme_forward_amounts,\n    solution_isozyme_reverse_amounts,\n    solution_fluxes,\n    gene_zero_tol::Float64\n) -> Dict\n\n\nReturn a freshly allocated dictionary mapping reaction IDs to isozyme structs. Note, all reactions running in reverse have their kcats swapped, since prune_model changes all fluxes to be positive.\n\nExample\n\nprune_reaction_isozymes(reaction_isozymes, solution.isozyme_forward_amounts, solution.isozyme_reverse_amounts, solution.fluxes, 1e-6)\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.differentiate_objective-Tuple{Any, Vector{Float64}, Vector{Float64}, Vector{Float64}, Dict{Symbol, Float64}}","page":"Reference","title":"DifferentiableMetabolism.differentiate_objective","text":"differentiate_objective(\n    ,\n    primal_vals::Vector{Float64},\n    eq_dual_vals::Vector{Float64},\n    ineq_dual_vals::Vector{Float64},\n    parameter_values::Dict{Symbol, Float64}\n) -> Any\n\n\nDifferentiate the objective of a model with respect to the variables. The first argument is the output of differentiate_prepare_kkt, and is a tuple of the deconstructed model. The following arguments (primal_vals, eq_dual_vals, ineq_dual_vals) are outputs of optimized_values. parameter_values\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.differentiate_prepare_kkt-Tuple{ConstraintTrees.ConstraintTree, ConstraintTrees.Value, Vector{Symbol}}","page":"Reference","title":"DifferentiableMetabolism.differentiate_prepare_kkt","text":"differentiate_prepare_kkt(\n    m::ConstraintTrees.ConstraintTree,\n    objective::ConstraintTrees.Value,\n    parameters::Vector{Symbol};\n    make_expressions\n) -> Tuple{Tuple{Union{Expr, RuntimeGeneratedFunctions.RuntimeGeneratedFunction}, Union{Expr, RuntimeGeneratedFunctions.RuntimeGeneratedFunction}, Union{Expr, RuntimeGeneratedFunctions.RuntimeGeneratedFunction}, Vector{Symbol}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}}, Any}\n\n\nPrepare a model m with objective for differentiation with respect to parameters.\n\nThis is the most time consuming aspect of differentiation. It pays off to do this separately  if the same model will be differentiated multiple times.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.differentiate_solution-Tuple{Any, Vector{Float64}, Vector{Float64}, Vector{Float64}, Dict{Symbol, Float64}}","page":"Reference","title":"DifferentiableMetabolism.differentiate_solution","text":"differentiate_solution(\n    ,\n    primal_vals::Vector{Float64},\n    eq_dual_vals::Vector{Float64},\n    ineq_dual_vals::Vector{Float64},\n    parameter_values::Dict{Symbol, Float64};\n    scale\n) -> Any\n\n\nDifferentiate a solution of a model. The first argument is the output of differentiate_prepare_kkt, and is a tuple of the deconstructed model. The following arguments (primal_vals, eq_dual_vals, ineq_dual_vals) are outputs of optimized_values. parameter_values\n\n\n\n\n\n","category":"method"},{"location":"reference/#DifferentiableMetabolism.findall_indeps_qr-Tuple{Any}","page":"Reference","title":"DifferentiableMetabolism.findall_indeps_qr","text":"findall_indeps_qr(A) -> Any\n\n\nReturn all linearly dependent constraints in  A, using the QR decomposition.\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableMetabolism.jl","page":"README","title":"DifferentiableMetabolism.jl","text":"Documentation for DifferentiableMetabolism.","category":"section"},{"location":"#DifferentiableMetabolism.DifferentiableMetabolism","page":"README","title":"DifferentiableMetabolism.DifferentiableMetabolism","text":"module DifferentiableMetabolism\n\nDifferentiate parameterized genome-scale metabolic models. Currently, FastDifferentiation parameters are used in conjunction with COBREXA models. To ensure your derivatives are well defined, you must ensure that the models are pruned, i.e. all active reactions, genes, etc. have nonzero values at the optimum. See the documentation for model details and examples.\n\n\n\n\n\n","category":"module"}]
}
